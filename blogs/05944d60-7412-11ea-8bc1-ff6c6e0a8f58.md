[1 初始化](#1)


[2 创建一张平面](#2)


[3 屏幕坐标与世界坐标转化](#3)


&emsp;[3.1 屏幕->世界](#3-1)


&emsp;[3.2 世界->屏幕](#3-2)


[4 鼠标事件](#4)


[5 绘制一个点](#5)


[6 绘制一条线](#6)


[7 长度测量](#7)


[8 角度](#8)


&emsp;[8.1 角度测量](#8-1)


&emsp;[8.2 角度绘制](#8-2)


&emsp;[8.3 角度标签](#8-3)


[9 总结](#9)

articleLine


## <span id="1" class="title">1 初始化</span>
如果了解过ThreeJs应该都清楚4个基本的初始化及一些辅助工具，项目目前包含6个初始化对象：  
> 1. 环境  
> 2. 相机  
> 3. 灯光（环境光和光源）  
> 4. 渲染器  
> 5. 控制器  
> 6. 性能插件

## <span id="2" class="title">2 创建一张平面</span>

&emsp;绘制3D房型图我计划时通过点-线-面-体的方式逐步构建，所以需要用一张平面作为底（或者说是地面），项目中坐标大小与实际长度大小比例为：  

> 坐标 : 米 = 50 : 1


实际使用中通常将该平面设置得比需求面略大，最后在通过删除该平面获得绘制的图形。


```js
function initPlane(x,y){
	let geometry = new THREE.PlaneGeometry(x,y)
	let material = new THREE.MeshLambertMaterial({
	  color : 0xd9d9d9,
	  side: THREE.DoubleSide,
	})
	Plane = new THREE.Mesh(geometry,material)
	scene.add(Plane)
}
initPlane(600,500) //12米*10米
```

## <span id="3" class="title">3 屏幕坐标与世界坐标转化</span>
&emsp;ThreeJs是3维空间，且以绘图中心为原点，与屏幕坐标有区别，所以在使用过程中经常需要互相转化。

## <span id="3.1" class="title">3.1 屏幕->世界</span>
&emsp;项目中需要通过鼠标绘制点，所以需要将鼠标的坐标映射到世界坐标中，思路是：**从相机位置向鼠标方向发射一条射线，获取射线第一个接触的对象的坐标**，这也是获取点击物体的一个方法。  
&emsp;Threejs中提供了发射射线的方法（raycaster），我利用这个方法来获取到鼠标点击平面的坐标，从而在平面上绘制一个点：
```js
// event : 点击的参数
// obj : 一个数组，我传入了[Plane],就是第二步绘制的平面
function getMouseObj(event,obj){
  // 标准化设备
  let mouse = new THREE.Vector2();
  mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1
  mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1
  
  //从相机位置朝点击方向发射射线
  let raycaster = new THREE.Raycaster()
  raycaster.setFromCamera(mouse,camera)
  
  // 获取到射线接触到的对象
  let intersects = raycaster.intersectObjects(obj)
  if(intersects.length > 0){
    return intersects[0] // 包含射线经过的长度，以及接触点的坐标
  }
  else
    return false
}
```

## <span id="3.2" class="title">3.2 世界->屏幕</span>
&emsp;目前使用到该方法的地方是定位角度标签的位置，需要将角度标签放在夹角处显示（该标签是一个div），详细看后文。
```js
const wordVector = new THREE.Vector3(x,y,z)
const screenPos = wordVector.project(camera)
const x = Math.round(screenPos.x * width/2 + width/2)
const y = Math.round(-screenPos.y * height/2 + height/2)
```

## <span id="4" class="title">4 鼠标事件</span>
&emsp;绘制函数参考下文
```js
document.body.onmousedown = (e) => {
	// 阻断控制器
	controls.enabled = false
}
document.body.onmouseup = (e) => {
	if(e.button === 0){//鼠标左键
	  let pos = getMouseObj(e,[Plane]).point
	  if(pos){
		//在鼠标位置画点
	    lastPoints = drawDot(pos)
		// 判断是否是重复点，重复点不添加
	    const dots = dotGroup.children.find(item => {
	      return JSON.stringify(lastPoints.position) === JSON.stringify(item.position)
	    })
	    if(!dots)
	      dotGroup.add(lastPoints)
		// 将临时线添加到线组中
	    if(scene.getObjectByName("tempLine")){
	      let line = scene.getObjectByName("tempLine").clone()
	      line.name = "line" + lineGroup.children.length
	      lineGroup.add(line)
			lastLine = line
	    }
	  }
	}
	controls.enabled = true
}
document.body.onmousemove = (e) => {
  let pos = getMouseObj(e,[Plane]).point
  if(!pos) return
  removeTemp()
  // 实时画点
  let tempDot = drawDot(pos)
  tempDot.name = "tempDot"
  scene.add(tempDot)
  // 画线
  drawLine(pos,e)
}
function removeTemp(){
	scene.remove(scene.getObjectByName("tempDot"))
	scene.remove(scene.getObjectByName("tempCircle"))
	scene.remove(scene.getObjectByName("tempLine"))
	mouseVector = ""
	document.querySelectorAll('.label').forEach(item => {
		item.innerText = ""
	})
}
```

## <span id="5" class="title">5 绘制一个点</span>
&emsp;Threejs默认的点是正方形的，需要绘制圆形的话就需要通过贴图的形式。用到一个靠近吸附的功能，实现的思路是：

> 已知：点的圆心为鼠标的坐标；点的半径。  
> 假设鼠标附近形成一个圆，判断该圆是否与已有坐标靠近  
> 如果靠近则将点的圆心与该已知点的圆心重叠

```js
// 加载贴图
var pointsTexture = new THREE.TextureLoader().load('./imgs/dot.png')
// 绘制点
function drawDot(vector){
 	//vector是鼠标点击平面的坐标，参数来源参考3.1
  
	// 当前鼠标位置
	mouseVector = new THREE.Vector3(vector.x,vector.y,2)
	
	// 判断鼠标点是否与某个点靠近,有靠近时自动吸附
	const intersect = dotGroup.children.find(item => {
		const itemPos = item.position
		// 5不是一个固定的值，约大吸附范围越大，经调试得来
		return checkIntersect(itemPos,mouseVector,5)
	})
	if(intersect)
		mouseVector = intersect.position
	
	let points = new THREE.Sprite(new THREE.SpriteMaterial({
		map : pointsTexture
	}))
	points.scale.set(15,15,0)
	
	points.position.set(mouseVector.x,mouseVector.y,2)
	return points
}
//判断两个球是否相交
function checkIntersect(p1,p2,r){
  const maxX1 = p1.x + r
  const minX1 = p1.x - r
  const maxX2 = p2.x + r
  const minX2 = p2.x - r
  const maxX = Math.max(minX1,minX2)
  const minX = Math.min(maxX1,maxX2)
  
  const maxY1 = p1.y + r
  const minY1 = p1.y - r
  const maxY2 = p2.y + r
  const minY2 = p2.y - r
  const maxY = Math.max(minY1,minY2)
  const minY = Math.min(maxY1,maxY2)
  
  if(maxX < minX && maxY < minY)
    return true
  else
    return false
}
```

## <span id="6" class="title">6 绘制一条线</span>
先上源码再解释：html里需要创建2个标签，都设置成绝对定位即可
```js
function drawLine(vector,e){
   // 判断是否有两个点（第一次只有一个点)
   if(lastPoints){
	// 角度计算，向量由固定点指向两端
	if(lastLine){
		const p0 = lastLine.geometry.vertices[1]
		const p1 = lastLine.geometry.vertices[0]
		const p2 = vector
		const p01 = new THREE.Vector3(p1.x - p0.x,p1.y - p0.y,0)
		const p02 = new THREE.Vector3(p2.x - p0.x,p2.y - p0.y,0)
		const angle = p01.angleTo(p02)
		
		// 计算p0方程
		const k = p01.y / p01.x
		const b = p0.y - k*p0.x
		const x = (p2.y-b) / k
		
		// 画角度标记
		angleLabel.innerText = (angle * 180 / Math.PI).toFixed(1) + "°"
		// 角平分角度 = 两边角度和/2
		const unitX = new THREE.Vector3(1,0,0)
		let angle1 = p01.angleTo(unitX)
		let angle2 = p02.angleTo(unitX)
		// 向量向下,角度取负
		if(p01.y < 0){
			angle1 = -angle1
			// 临时点在固定点左侧
			if(p2.x < x)
				angle1 = 2*Math.PI + angle1
		}
		if(p02.y < 0){
			angle2 = -angle2
			// 临时点在固定点左侧
			if(p2.x < x)
				angle2 = 2*Math.PI + angle2
		}
		
		const divideAngle = (angle1+angle2) / 2
		// 固定角平分线长度，求出坐标
		const lengthX = Math.cos(divideAngle) * 50
		const lengthY = Math.sin(divideAngle) * 50
		let divideX = p0.x + lengthX
		let divideY = p0.y + lengthY
		const wordVector = new THREE.Vector3(divideX,divideY,2)
		console.log(divideAngle*180/Math.PI)
		// 世界坐标转屏幕坐标
		const screenPos = wordVector.project(camera)
		angleLabel.style.left = Math.round(screenPos.x * width/2 + width/2) + 'px'
		angleLabel.style.top = Math.round(-screenPos.y * height/2 + height/2) + 'px'
		
		// 定义初始角度与旋转方向
		let startAngle = p01.angleTo(new THREE.Vector3(1,0,0))
		let endAngle = startAngle + angle
		let direction = false
		// 向量向下
		if(p01.y < 0){
			startAngle = -startAngle
			endAngle = startAngle + angle
			if(p2.x < x){
				direction = true
				endAngle = startAngle - angle
			}
		}
		// 向量向上且点在线右边
		if(p01.y > 0 && p2.x > x){
			direction = true
			endAngle = startAngle - angle
		}
			
		// 以夹角点画弧度
		let curve = new THREE.EllipseCurve(
			lastPoints.position.x,lastPoints.position.y, //圆点坐标
			20, 20, // x,y半径
			startAngle,endAngle, // 开始结束的角度
			direction //是否顺时针
		)
		let points = curve.getPoints(50)
		let geometry = new THREE.BufferGeometry().setFromPoints(points)
		let material = new THREE.LineBasicMaterial({color : 0xff0000 })
		let circle = new THREE.Line(geometry,material)
		circle.position.z = 2
		circle.name = 'tempCircle'
		scene.add(circle)
	}//角度绘制结束
		
	// 长度计算
	const last = lastPoints.position
	const length = (Math.sqrt(Math.pow(last.x-mouseVector.x,2)+Math.pow(last.y-mouseVector.y,2)) / ratio).toFixed(2)
	lengthLabel.innerText = length
	lengthLabel.style.left = e.offsetX + 10 + 'px'
	lengthLabel.style.top = e.offsetY + 10 + 'px'
	
	// 两点画线
	let LineMaterial = new THREE.LineBasicMaterial({color:0x0000ff})
	let LineGeometry = new THREE.Geometry()
	let p = lastPoints.position
    LineGeometry.vertices.push(p,mouseVector)
    
    let line = new THREE.Line(LineGeometry,LineMaterial)
    line.name = 'tempLine'
    scene.add(line)
  }
}
```

看起来很长，大部分都是为了获得角度和长度的代码，如果是单纯的画线就很简单，直接根据两个点绘制（上一个点，鼠标当前点）

```js
// 两点画线
let LineMaterial = new THREE.LineBasicMaterial({color:0x0000ff})
let LineGeometry = new THREE.Geometry()
let p = lastPoints.position
LineGeometry.vertices.push(p,mouseVector)

let line = new THREE.Line(LineGeometry,LineMaterial)
line.name = 'tempLine'
scene.add(line)
```

## <span id="7" class="title">7 长度测量</span>
用到两个之间的距离公式（应该都懂吧）
```
// 长度标签的位置为鼠标附近
const last = lastPoints.position
// .toFixed(number) 指定小数位数
const length = (Math.sqrt(Math.pow(last.x-mouseVector.x,2)+Math.pow(last.y-mouseVector.y,2)) / ratio).toFixed(2)
lengthLabel.innerText = length
lengthLabel.style.left = e.offsetX + 10 + 'px'
lengthLabel.style.top = e.offsetY + 10 + 'px'
```

## <span id="8" class="title">8 角度</span>
### <span id="8.1" class="title">8.1 角度测量</span>
最头大的一个部分，测角度不是很难，画弧度与定位标签有点难搞。这里的我定义向量是由夹角点指向两端，如图：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200401185426235.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lqbHRvcA==,size_16,color_FFFFFF,t_70#pic_center)


```js
// 角度肯定要两条线，用lastLine记录上一条直线的信息
const p0 = lastLine.geometry.vertices[1] // 上条直线的第二个点（夹角点）
const p1 = lastLine.geometry.vertices[0] // 上条直线的第一个点
const p2 = vector // 当前鼠标的位置
const p01 = new THREE.Vector3(p1.x - p0.x,p1.y - p0.y,0)
const p02 = new THREE.Vector3(p2.x - p0.x,p2.y - p0.y,0)
// vector3的方法，可以计算两条向量的夹角，返回弧度大小
const angle = p01.angleTo(p02)
```
一开始没有发现angleTo这个方法，用了余弦定理算角度，有兴趣的可以练习下（补习下几何）

### <span id="8.2" class="title">8.2 角度绘制</span>
  
绘制角度有3个关键点：  
1. 确定初始角度
2. 确定绘制方向
3. 确定结束角度

```js
// 计算p01方程
const k = p01.y / p01.x
const b = p0.y - k*p0.x
const x = (p2.y-b) / k

// 其实角度为0时表示从3点钟方向开始绘制。逆时针为正角度
let startAngle = p01.angleTo(new THREE.Vector3(1,0,0))
let endAngle = startAngle + angle
// false逆时针，true顺时针
let direction = false
// 向量向下
if(p01.y < 0){
	startAngle = -startAngle
	endAngle = startAngle + angle
	if(p2.x < x){
		direction = true
		endAngle = startAngle - angle
	}
}
// 向量向上且点在线右边
if(p01.y > 0 && p2.x > x){
	direction = true
	endAngle = startAngle - angle
}
```
简略后的代码，不嫌麻烦的可以将4种情况分开写，起始点定在已经固定的直线上，结束点定在可转动的直线上。这里需要注意angle始终是正的，所以计算时候需要考虑startAngle的正负。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200401191026305.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lqbHRvcA==,size_16,color_FFFFFF,t_70#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200401191035476.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lqbHRvcA==,size_16,color_FFFFFF,t_70#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200401191044975.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lqbHRvcA==,size_16,color_FFFFFF,t_70#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200401191054761.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lqbHRvcA==,size_16,color_FFFFFF,t_70#pic_center)

### <span id="8.3" class="title">8.3 角度标签</span>
角度标签绘制在夹角弧度的前面，我的想法是求出夹角的角平分线，然后取固定的长度求出坐标，最后将世界坐标转化成屏幕坐标。
```js
angleLabel.innerText = (angle * 180 / Math.PI).toFixed(1) + "°"
// 角平分线角度 = 两边角度和 / 2
const unitX = new THREE.Vector3(1,0,0)
// 与x轴正方向夹角
let angle1 = p01.angleTo(unitX)
let angle2 = p02.angleTo(unitX)
// 向量向下,角度取负
if(p01.y < 0){
	angle1 = -angle1
	// 临时点在固定点左侧
	if(p2.x < x)
		angle1 = 2*Math.PI + angle1
}
if(p02.y < 0){
	angle2 = -angle2
	// 临时点在固定点左侧
	if(p2.x < x)
		angle2 = 2*Math.PI + angle2
}
const lengthX = Math.cos(divideAngle) * 50
const lengthY = Math.sin(divideAngle) * 50
let divideX = p0.x + lengthX
let divideY = p0.y + lengthY
// 世界坐标转屏幕坐标
const wordVector = new THREE.Vector3(divideX,divideY,2)
const screenPos = wordVector.project(camera)
angleLabel.style.left = Math.round(screenPos.x * width/2 + width/2) + 'px'
angleLabel.style.top = Math.round(-screenPos.y * height/2 + height/2) + 'px'
```

我画了两张图帮助理解。因为angleTo得到的角度范围是0-180，没有负角度，需要根据向量位置进行计算。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020040120010074.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lqbHRvcA==,size_16,color_FFFFFF,t_70#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200401200114102.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lqbHRvcA==,size_16,color_FFFFFF,t_70#pic_center)

## <span id="9" class="title">9 总结</span>
&emsp;太久没学几何，好多知识都不急得了。差点连直线方程都不会求了。目前帧率还是挺稳定的，说明计算量不是很大，之前想直接用threejs里的字体，但是发现它的加载太耗时间，不适合实时更新，现在角度标签的定位还不是很好，如果有更好的思路麻烦在底部留言。

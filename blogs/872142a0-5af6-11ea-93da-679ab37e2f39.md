[1 express框架](#1)  


[2 connect-history-api-fallbac](#2)  


[3 请求接口](#3)  


&emsp;[3.1 跨域配置](#3-1)  


&emsp;[3.2 路由接口](#3-2)  


&emsp;[3.3 初始数据读取](#3-3)  
 

&emsp;[3.4 新增文章](#3-4)  


&emsp;[3.5 增加阅读量](#3-5)  


articleLine

博客项目3——后台设计
本章主要介绍后台接口设计

## <span id="1" class="title">1 express框架</span>
&emsp;&emsp;express是node.js的web开发框架，简单实用，使用javascript语法，非常适合掌握前端开发的人学习，无需额外学习语法。博客采用**express+mysql+json**的方式存储数据，目前包含一个数据表（用于存储每篇文章的主要信息），一个json文件（存储一些统计信息跟基本不会变化的信息）。**用到的库：**    
>1. body-parser //处理post请求数据传递。  
>2. connect-history-api-fallback //解决vuecli路由在history模式下找不到界面问题。  
>3. mysql //数据库操作  
>4. uuidd //生成唯一标识码  


## <span id="2" class="title">2 connect-history-api-fallbac</span>
&emsp;&emsp;之前一直没注意到这个中间件，似乎也只有express框架可以用它，非常容易解决了vuecli项目路由错误问题。
```javascript
var history = require('z')
app.use(history({
  rewrites: [//重定向
    { 
      from: /^\/blogs\/.*$/, 
      to: function(context) {
        return context.parsedUrl.path
      }
    },
  ]
}))
```
&emsp;&emsp;vue项目刷新后404主要问题就是vue本身的路由与后台路由冲突，正常情况下浏览器请求地址会默认走服务器的路由，而vue项目中服务器路由只需定义根路由，其他路由由vue-route配置，因此在网页中除了根路径外的路由刷新后浏览器是找不到界面的。  
&emsp;&emsp;connect-history-api-fallbac的作用就是阻止浏览器部分请求，被阻止的请求满足如下形式：  
>1. 请求是Get请求  
>2. 请求的Content-Type类型是text/html类型  
>3. 不是直接的文件请求，即所请求的路径不包含.(点)字符  
>4. 不匹配option参数中提供的模式  


&emsp;&emsp;将满足上述请求的路径转为请求vue-route的路径从而找到真正的路由界面。但同时也会阻断部分get数据请求，因此需要在rewrites单独将这部分请求接口声明。from中匹配请求的地址，使用了一个正则表达式，意为当get请求为/blogs/......的格式时会将这个请求转向寻找服务器的接口。如果不声明的话，get请求的接口是找不到的。这里推荐个查看正则表达意思的网址 [验证正则表达](https://regexper.com/#%2F%5E%5C%2Fblogs%5C%2F.*%24%2F) 将正则表达式放进去会以非常形象的结构展示正则表达作用。  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200229201233695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lqbHRvcA==,size_16,color_FFFFFF,t_70)

## <span id="3" class="title">3 请求接口</span>
目前包含2个路由接口，2个获取数据借口，2个修改数据借口。
### <span id="3-1" class="title">3.1 跨域配置</span>
不多介绍，都是套路。也可以通过配置服务器解决。
```javascript
app.all('*', function(req, res, next) {
  res.header("Access-Control-Allow-Origin", "*");
  res.header('Access-Control-Allow-Headers', 'Content-type');
  res.header("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS,PATCH");
  res.header('Access-Control-Max-Age',1728000);//预请求缓存20天
  next();  
});
```
### <span id="3-2" class="title">3.2 路由接口</span>
```javascript
//定义静态文件路径
  app.use(express.static(__dirname+'/static'))
  app.use(express.static(__dirname+'/static/dist'))
  //请求界面
  app.get('/', (req, res) => {
    res.sendFile(__dirname + '/static/dist/index.html') //vue打包后文件夹
  })
  //访问图片
  app.get('/img/:name',(req,res) => {
    const name = req.params.name
    const rs = fs.createReadStream(`${__dirname}/static/img/${name}`) //获取图片的文件名
    rs.pipe(res)
  })
  ```
### <span id="3-3" class="title">3.3 初始数据读取</span>
&emsp;&emsp;博客的一些基本信息以json文件的格式存储，包括文章统计量，标签，分类及个人信息。而每篇文章的重要信息（标题，简介，日期，作者等重要信息存储在数据库中），文章的主要内容以md文件格式存储。
```javascript
app.get('/blogs/getInfo',(req,res) => {
	//读取json文件数据
	let result = JSON.parse(fs.readFileSync(__dirname + "/blogsInfo/baseInfo.json",'utf8'))
	// 读取数据库中博客列表
	const sql = `select * from blogsList` 
	db.query(sql,(err,dbres) => {//db为连接数据库后变量
	  if(err) throw err
	  result.blogsList = dbres
	  res.json(result)
	})
})
```


没有啥复杂的东西，但是通常情况下不会请求所有数据库中的所有数据，少量数据没太多问题，但几百条数据话就会很慢，应该是每次限制请求一定数量数据为好，后面会改进。  
### <span id="3-4" class="title">3.4 新增文章</span>
 写文章目前是在csdn上的markdown编辑器书写，然后在上传到服务器中，再通过一次post请求更新数据。  
 
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200229204626387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lqbHRvcA==,size_16,color_FFFFFF,t_70)  
<center>数据表结构</center>  

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200229204420326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lqbHRvcA==,size_16,color_FFFFFF,t_70)
<center>json数据结构</center> 



```javascript
app.post('/blogs/addBlogs',(req,res) => {
	const param = req.body
	let blogsInfo = JSON.parse(fs.readFileSync(__dirname + "/blogsInfo/baseInfo.json",'utf8'))
	addBlogs(param,blogsInfo,db)//更新json数据
	.then((data,err) => {
	  if(err) throw err
	  res.send(data)
	})
})
function addBlogs(param,blogsInfo,db){
  return new Promise((resolve,reject) => {
    /* 更新数据库*/
    param.date = new Date()
    param.id = uuid.v1()
    const sql = 'insert into blogsList set ?'
    db.query(sql,param,(err,res) => {
      if(err) reject(err)
      /* 更新json数据*/
      // 更新categeroys的amount 以及标签
      blogsInfo.categeroy.find(item => {
        if(item.text === param.categeroy){
          item.amount++
          switch(item.text){//更新tags
            case "日记":item.tags=updateTags(item.tags,param.tags);break;
            case "游记":item.tags=updateTags(item.tags,param.tags);break;
            case "技术":item.tags=updateTags(item.tags,param.tags);break;
          }
        }
        return item.text === param.categeroy
      })
      blogsInfo.article++//更新总数
      //保存json文件
      let json = JSON.stringify(blogsInfo,"","\t")
      fs.writeFileSync('./blogsInfo/baseInfo.json',json)
      //修改blogs文件名称
      fs.renameSync(__dirname+'/blogs/blogs.md',__dirname+"/blogs/"+param.id+".md")
      resolve(blogsInfo)
    })
  })
}

function updateTags(tags,param){
  param = param.split(',')
  param.forEach(tag => {
    if(tags.indexOf(tag) === -1)
      tags.push(tag)
  })
  return tags
}
```
&emsp;&emsp;存储到数据表中的参数除了date跟id由程序生成，其他都是post传入。这里比较麻烦的就是处理json中的tags，需要判断下有没有重复的标签，用到了indexof,判断数组中是否包含某个元素，若包含返回大于-1的值，若不包含吧返回-1。若新标签包含在旧标签内则不再新增标签。同时用到promise方式，将异步请求变成同步请求，因为请求数据库是异步的，如果不转同步话数据库操作还没结束就已经返回结果了。  

### <span id="3-5" class="title">3.5 增加阅读量</span>
在进入文章并停留5分钟后会先服务器发送一个增加阅读量的请求。
```javascript
/* 增加阅读量*/
 app.post('/blogs/addReaded/',(req,res) => {
   const data = req.body
   let sql = `select * from blogsList`
   db.query(sql,(err,result) => {
     if(err) throw err
     let blogs = result.find(item => {
       return item.id === data.id
     })
     sql = `update blogsList
            set readed=${++blogs.readed}
            where id='${blogs.id}'
           `
     db.query(sql,(err,result) => {
       if(err) throw err
       res.send(result)
     })
   })
 }))
```
前端传入文章的id，服务器读取该文章最新的阅读量后进行+1再存储。一开始我是想传入前端的阅读量进行+1，但是后来想到两个人同时阅读的话就会出现bug了。
- - - 
目前博客还没太复杂的接口程序，都是些简单的读取和修改，以后如果有些比较新鲜的接口再跟大家分享。

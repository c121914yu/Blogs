[1 第四周](#1)


&emsp;[1.1 类的一些知识](#1-1)


&emsp;[1.2 时钟类](#1-2)


&emsp;[1.3 循环计时器](#1-3)


[2 第五周](#2)


&emsp;[2.1 构造函数](#2-1)


&emsp;[2.2 析构函数](#2-2)


&emsp;[2.3 对象的数组和指针](#2-3)


&emsp;[2.4 对象的复制和拷贝](#2-4)


[3 第六周](#3)


&emsp;[3.1 对象的赋值](#3-1)


&emsp;[3.2 共用数据保护](#3-2)


&emsp;[3.3 静态成员](#3-3)


&emsp;[3.4 友元](#3-4)


articleLine

## <span id="1" class="title">1 第四周</span>
本周没有太多知识点，只要以实操为主。以停车收费为例子。

### <span id="1-1" class="title">1.1 类的一些知识</span>
**const 定义常成员函数**，不能更新成员变量，也不能调用类中未用const修饰的函数，只能调用其他常成员函数。


### <span id="1-2" class="title">1.2 时钟类</span>
停车时间=leaveTime - arriveTime  
两个time可共用一个时钟类，实例化两个不同时间的时钟。  
考虑兼容性：  
1. 24H/12H格式
2. 时间归一化（统一为分钟）

### <span id="1-3" class="title">1.3 循环计数器</span>
实际中我们将角度规定为0-359，月份1-12， 小时0-23等，而不会让数值无限放大。  
计算公式： 
> 摸 = 最大值 - 最小值 +1  
> 下一个 = （当前-最小+1）%摸 + 最小  
> 上一个 =  （当前-最小-1+摸）%模 + 最小
 
 ## <span id="2" class="title">2 第五周</span>

### <span id="2-1" class="title">2.1 构造函数</span>
对象初始化-构造函数：
> * c++98中不允许用表达式初始化
> * 构造函数与类名相同
> * 不指定返回类型
> * 可根据需求设置参数
> * 可以含多个构建函数，参数不同

```cpp
// 写法1，在clock.hpp中
class clock{
 public:
 	clock(){hour=0;minute=0;}
}
// 写法2，在clock.cpp中
clock::clock():hour(0),minute(0){}
// 写法3，在clock.cpp中
clock::clock(){
  hour=0;minute=0;
}
```

### <span id="2-2" class="title">2.2 析构函数</span>
> * 名字必须是类名前加一个~，以区别构造函数  
> * 不能指定返回类型  
> * 不能指定任何形式参数，不能重载  

### <span id="2-3" class="title">2.3 对象的数组和指针</span>
```cpp
class Box{}

// main
Box a[3] // 无参构造
Box b[3] = {}//定义对象数组
Box(10,12,15) // 含参构造

Box b1(10,13,15)

// new/delete
Box *p1,p2;
p1 = new Box();
p2 = new Box(1,2,3);
delete p1;
delete p2;

p1 = new Box[3] //存放对象组的起始地址
p2 = new Box[4]{Box(1,2,3),Box(1,2,3),Box()}
delete []p1;
delete []p2;
```

### <span id="2-4" class="title">2.4 对象的复制和拷贝</span>
> * 用一个对象去初始化另一个对象——拷贝构造函数  
>* 形式：类名(const 类名& obj){}  
> 拷贝函数在用自己已有对象复制另一个新对象时被调用  
> 需要克隆的情况：  
> 1. 声明语句中建立新对象时用已存在的对象初始化  
> 2.  将一个对象作为函数的参数按值调用方式传递给另一个对象
> 3. 生成一个临时对象作为返回结果。  

## <span id="3" class="title">3 第六周</span>
### <span id="3-1" class="title">3.1 对象的赋值</span>

```cpp
//成员函数
类名& operator = (const 类名& right){
	(*this).成员 = right.成员
	return *this;
}


ex2 objA(3), objB(4), objC;
cout << objA.getx() << endl;//3
cout << objB.getx() << endl;//4
cout << objC.getx() << endl;//0
objC = objA;
cout << objA.getx() << endl;//3
cout << objB.getx() << endl;//4
cout << objC.getx() << endl;//3
```

### <span id="3-2" class="title">3.2 共用数据保护</span>
>  **const关键字**  
> * 必须在定义时初始化  
> * 不能被修改  
> * 不能调用该对象非const的成员函数  
> * 常成员函数可读const和非const  
> * 常对象只能调用const成员函数  
> * 常成员函数不能调用另一个非const成员函数  
> 定义对象的常指针：类名* const 指针名    


调用函数时实参对象的值不能修改：  
1. 对象常引用 const clock& d  
2. 指向常对象的指针 const clock* ptr  
要求对象在函数调用时不能被修改，且执行过程不能被修改：  
1. 定义对象为常对象： const clock t1(12,0,5)  
2. 将类的所有数据局成员设计为常数据成员  

  
| 形式 | 含义 |
|--|--|
| const clock A(12,0,6) | A为常对象任何时候不可修改 |
| void clock::f() const | f为常成员函数，不能再f中修改值 |
| const clock * ptr;clock const *ptr | ptr1是常对象指针，*ptr1不可修改，ptr1可修改 |
| const clock& rA = A | rA是clock的常引用，不能通过rA修改A的值 |
| clock* const ptr=&A | ptr是常指针，ptr2不能修改，*ptr可修改 |
| const clock* const ptr=&A | ptr是指向常对象的指针常量，ptr和*ptr均不可修改 |

### <span id="3-3" class="title">3.3 静态成员</span>
> static关键字  
> * 属于类不属于某个对象  
> * 只能在类外初始化 数据类型 类名::静态数据成员们=初值  
> * 编译时分配空间，结束才被释放  
> * 可以通过对象名引用，也可以通过类名引用   

静态成员函数：  
> static int volumn()  
> * 和静态数据成员一样  
> * 无this指针，主要是用来访问静态数据  

### <span id="3-4" class="title">3.4 友元</span>
* friend关键字  
* 可以访问有好友关系的私有成员。包括友元函数和友元类。  
* 友元函数：在类中用friend对其进行声明，此函数称为本类的友元函数，友元函数可以访问这个类的私有成员。  

```cpp
class A
{
public:
  A(int b) { x = b; }
  friend void display(const A &);

private:
  int x;
};
void display(const A &obj)
{
  cout << obj.x;
}

int main()
{
  A obj(3);
  display(obj);
  return 0;
}
```

**友元成员函数** ：可以是一般成员函数，也可以是另一个类的成员函数  
**友元类** ：将一个类声明为另一个类的朋友，该类可以访问另一个类的所有成员。  

> 友元声明可以在类的任何位置  
> 友元是单向的  
> 友元关系不能传递  
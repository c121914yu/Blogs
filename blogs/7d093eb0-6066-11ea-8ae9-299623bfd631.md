[1 第一周](#1)


&emsp;[1.1 c++内置类型](#1-1)


&emsp;[1.2 类型扩展](#1-2)


&emsp;[1.3 整数书写常量类型识别](#1-3)


&emsp;[1.4 浮点数书写常量类型识别](#1-4)


&emsp;[1.5 字符书写常量类型识别](#1-5)


&emsp;[1.6 字符转义](#1-6)


&emsp;[1.7 数组](#1-7)


&emsp;[1.8 指针](#1-8)


&emsp;[1.9 指针与数组](#1-9)


&emsp;[1.10 空间申请与回收](#1-10)


[2 第二周](#2)


&emsp;[2.1 引用](#2-1)


&emsp;[2.2 内联函数](#2-2)


&emsp;[2.3 函数参数](#2-3)


&emsp;[2.4 重载机制](#2-4)


&emsp;[2.5 模板](#2-5)


[3 第三周](#3)


&emsp;[3.1 字符串](#3-1)


&emsp;[3.2 面向对象基础](#3-2)


[4 第四周](#4)

articleLine


## <span id="1" class="title">1 第一周</span>
### <span id="1-1" class="title">1.1 c++内置类型</span>

 字符 | 类型 | 字节数  
 - | - | -  
 char | 字符型 | 1字节  
 wchart_t | 宽字符型 | 2/4字节  
 char16_t | 宽字符型 | 2字节  
 char32_t | 宽字符型 | 4字节  
 int| 整型 | 2/4字节  
 long long | 长整型 | 8字节    
 float | 浮点型 | 4字节  
 double| 双精度型 | 8字节  
 bool| 布尔型 | 1字节  

### <span id="1-2" class="title">1.2 类型扩展</span>
&emsp;&emsp;typedef 类型 类型别名 (不创造新类型，只是定义别名)  
```cpp
typedef short int16_t
```

### <span id="1-3" class="title">1.3 整数书写常量类型识别</span>
前缀| 后缀| 类型 | 说明
- | - | - | -
- | - | 默认匹配int-long-long long | 十进制
0 | - |匹配int及unsigned int | 八进制
0x或0X | - |匹配int及unsigned int | 十六进制
0x或0X | - |匹配int及unsigned int | 十六进制
- | u/U | 最小匹配unsigned | 无符号整形
-  | l/L | 最小匹配long | 长整形
--  | Ll/LL | 最小匹配long long | 超长整形

### <span id="1-4" class="title">1.4 浮点数书写常量类型识别</span>
 后缀| 类型 | 说明
- | - | -
 - | 默认类型double| 双精度浮点型
 f/F | float | 单精度浮点型  
 l/L | long double | 扩展精度浮点型  
 
### <span id="1-5" class="title">1.5 字符书写常量类型识别</span>
  符号| 类型 | 说明
- | - | -
单引号 | char | 默认一个字符，转义字符外
双引号 | char[] | 字符串
u | char16_t | unicode 16字符
U | char32_t | unicode 32字符
L | wchar_t | 宽字符型 16/32位
u8 | char | utf-8字符 1-4字节

### <span id="1-6" class="title">1.6 字符转义</span>
> \x 后紧跟1-2 个十六进制数字  
>  \ 后紧跟 1-3 个八进制数字  

### <span id="1-7" class="title">1.7 数组</span>
声明：type name[][]....
 声明数组中不能使用变量，可以为常量或厂里表达式。  
> 几种正确的声明方法  
>  int name[100];  
>  double a[5] = {100.0,5.1,2.5};未声明部分默认为0  
>  int name[9][9];  
>  int a[2][3] = {1,2,3},{1,2,3};  
>  int a[][3] = {1,2,3},{1,2,3};  

### <span id="1-8" class="title">1.8 指针</span>
声明： 类型 *变量名  
用于存储地址，不能对不确定的指针进行读写。  
```cpp
int a = 1;
int *p;
p = &a; // p中存储a的地址，&可获取地址

int *p;
int* *q = &p;//q中存储指针p的地址

void *p;//void可存放任意类型地址,同时丢失类型信息，读写时需指定类型。  
*p = &a;
```

### <span id="1-9" class="title">1.9 指针与数组</span>
```cpp
int a[] = {2,4,6};
int b[2][3] = {1,2,3,4,5};
int *q = a;
int *r = b[0];
*r // b[0][0]
*(r+1) // b[0][1]
*（*(r+1)+2）//b[1][2]
*(r[1]+2) //b[1][2]
(*(c+1))[2] //b[1][2]

int *const p = a; //指针常量，必须初始化
const int *p = a; //常量指针
```

### <span id="1-10" class="title">1.10 空间申请与回收</span>
```cpp
//单个
int *p;
p = new int;
*p = 3;
cout << *p << endl; //3
delete p;
//成批
int *p = new int[3];
*p = 3; //p[0]=3
p[1] = 2; //*(p+1)=2
cout << *p;//p[0]=3
delete []p;
```
> 不可重复删除  
>  new，delete成对使用
>  及时释放指针置空

## <span id="2" class="title">2 第二周</span>
### <span id="2-1" class="title">2.1 引用</span>
相当于给变量起别名,且引用的变量不占空间
```cpp
// 基本语法
// 类型 &标识符 = 关联变量名
int a;
int &b = a;
b = 3; // a=b=3
// 指针引用
int *p = &a; // *p=0
p = &b; // *p=0
// const引用
a = 1;
const int &b = a; // b只可读
```
> 注意点
> 1. 被引用变量已被定义
> 2. 不占用空间
>  3. 数组不可引用，可引用其中一个值
>  4. 空指针不可引用

### <span id="2-2" class="title">2.2 内联函数</span>
问题：  
1. 不做类型检查  
2. 无法预料计算顺序  
3. 不能debug
```cpp
// 宏定义函数
#define f2(x) x*x 
#define g2(x) (x)*(x)
f2(a+b) // a+b*a+b
g2(a+b) // (a+b)*(a+b)

// 内联函数 inline
inline int g2(int x) {return x*x;}
int a = 2,b = 3,c;
c = g2(a+b); // g2(5)
c = g2(a-b);// g2(1)
```
> **内联规则**
> 1. 节省函数调用开销，在声明和定义头部前加入inline,适合小函数高配使用场景
> 2. 多次调用会导致函数多次复制，增加编译开销，导致执行程序变大
> 3. 不支持多量代码
> 4. 无法接受指针调用
> 5. 函数具有可变数目参数无法内联

### <span id="2-3" class="title">2.3 函数参数</span>
```cpp
// 一维数组传参
int Cmax(int []);
int a[5];
Cmax(a);
// 二维数组传参
int Cmax(int [][5]);
int a[5][5];
Cmax(a);
// 一级指针传参
int Cmax(int *arr) // = int Cmax(int arr[])
int a[5];
Cmax(a);
// 交换数值
void swap(int *a,int *b){
  int c = *a;
  *a = *b;
  *b = c;
}
swap(&a,&b);// 3 4 -> 4 3
```
> **函数引用特点**
> 1. 形参与实参共用实参空间  
>  2. 实参与形参严格匹配  
>  3. 形参可读实参也可写实参，用const解决  
>  4. 函数内创建的地址值全局有效，需要返回数组可以再指针内创建并返回地址值  

### <span id="2-4" class="title">2.4 重载机制</span>

允许参数数量及类型不同的函数取同名。
> **重载二义性**
> 函数重载的二义性：无法在多个重载函数中选择正确的函数进行调用，有时将无法生成目标代码。
> 原因：隐式类型转化，缺省参数
> 编译程序选择重载函数规则：1. 如果函数调用的实际参数类型与一个重载函数的形参类型完全匹配。2. 如果找不到与实际参数类型完全匹配的函数原型，但如果将一个类型转化成更高级类型后可以匹配，便会选择调用重载函数。**即**向上匹配符合规则的函数，若唯一则调用重载函数。


### <span id="2-5" class="title">2.5 模板</span>
```cpp
Type abs(Type x){
	cout << "Using template version.";
	return (x>0?x:-x);
}
```
> 注意：
> 1. 由template给出的每一个形式类属参数都必须出现在函数参数表中
> 2. 模板函数必须实例化才能使用
> 3. 调用时必须保证函数的实际类型与形参完全匹配
> 4. 与同名函数同时调用时顺序 ：非模板函数参数完全匹配 -> 模板函数参数与调用匹配 -> 非模板隐式转化匹配 -> 错误

## <span id="3" class="title">3 第三周</span>
### <span id="3-1" class="title">3.1 字符串</span>
> * c风格：char[]  
> * string类  
> * 一个字符串包含起始地址和中止地址  
> * 可通过类型转化看其他类型数组  

```cpp
// 字符串初始化
char a[5] = {"a","b","c","d","e"};
char a[] = {"a","b","c"};
char a[] = "abc";
// 4种写入方式
//1. cin:不读入分隔符，空格，tab，换行
cin >> s;
//2. cin.getline:通过结束符（换行）来确定结束，不读入结束符
cin.getline(s,length,结束符)
//3. cin.get():4种重载形式，能读入所有输入的内容，包括结束符,一次读一个
char ch;
char s[100];
//读入字符
ch = cin.get();
cin.get(ch);
//读入串
cin.get(s,20);
cin.get(s,20,结束符);
//4. gets()
gets(s);
pits(s);
```

> 1. **字符串方法**  
>   strlen(s) - 获取长度  
>   strcmp(s1,s2) - 比较  
>   strcop(s) - 拷贝  
>   strcat(s1,s2) - 连接  
> 2.  **string类**  
>  str.max_size() 求极限长度  
>  str.length() - 字符串长度  
>  支持关系运算，赋值计算，加减运算  
>  支持下标读写

### <span id="3-2" class="title">3.2 面向对象</span>
> * 类以hpp文件格式，被主程序引入  
> * 类声明 class name{}  
> * public : 公共  
> * private : 私有  
> * 类的实现方式：  
> &emsp;1. x.hpp中声明数据及函数  
> &emsp;2. x.cpp中定义函数  
> &emsp;3. A.cpp中调用类  

```cpp
//类函数定义
返回类型 类名::函数名(变量){}
double pool:area(){
	return ***;
}
```

## <span id="4" class="title">4 第四周</span>
**const成员函数：**  
1. const成员函数只能被const对象引用  
2. const成员函数内可以引用const数据成员和非const数据成员，但是不能修改非const成员的值。也不能调用非const成员函数  
3. 在声明和定义时都要加上const  

**循环计数器**  
模 = 最大值 - 最小值 + 1  
next = (当前值-最小值+1)  % 模 + 最小值  
last = (当前值-最小值-1+模) % 模 + 最小值  